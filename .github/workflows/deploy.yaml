# yaml-language-server: $schema=https://json.schemastore.org/github-workflow.json
name: CI/CD Pipeline for Hello-World App (OIDC + IRSA + Pod Identity)

# This workflow builds, tests, and deploys the application and its infrastructure sequentially.
# It uses OIDC for secure, keyless authentication to AWS.
#
# Workflow Logic (Sequential):
# 1. Test: Runs linting and tests on the application code.
# 2. Deploy Infra: Deploys AWS infrastructure (EKS Cluster, IAM roles, etc.) using Terraform.
# 3. Build & Push: Builds the Docker image, scans it, and pushes it to the ECR repo created in the previous step.
# 4. Deploy App: Deploys the application to the EKS cluster using Kustomize.
# 5. Notify: Reports the final status of the deployment.

on:
  workflow_dispatch:

permissions:
  contents: read
  actions: read

env:
  AWS_REGION: us-east-1
  CLUSTER_NAME: thrive-cluster-test
  ECR_REPOSITORY: hello-world
  IMAGE_TAG: ${{ github.sha }}

jobs:
  test:
    name: üß™ Test Application
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: app/package-lock.json

      - name: Install dependencies
        working-directory: ./app
        run: npm ci

      - name: Run tests
        working-directory: ./app
        run: 'npm test || echo "No tests configured yet"'

      - name: Lint code
        working-directory: ./app
        run: 'npm run lint || echo "No linting configured yet"'

  deploy-infrastructure:
    name: üèóÔ∏è Deploy Infrastructure
    needs: test
    runs-on: ubuntu-latest
    environment: AWS_OIDC # GitHub Environment with AWS_ACCOUNT_ID secret
    permissions:
      id-token: write # Required for OIDC authentication
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/thrive-cluster-test-github-actions-role
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActionsTerraform

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Verify Backend Infrastructure
        run: |
          echo "üîç Verifying Terraform backend infrastructure..."
          aws s3api head-bucket --bucket "thrive-cluster-test-terraform-state" >/dev/null || \
            (echo "‚ùå S3 backend bucket not found! Please run the 'Provision AWS Backend' workflow first." && exit 1)
          echo "‚úÖ S3 backend bucket found."
          aws dynamodb describe-table --table-name "thrive-cluster-test-terraform-locks" --region ${{ env.AWS_REGION }} >/dev/null || \
            (echo "‚ùå DynamoDB lock table not found! Please run the 'Provision AWS Backend' workflow first." && exit 1)
          echo "‚úÖ DynamoDB lock table found."

      - name: Terraform Init
        id: init
        run: |
          terraform init \
            -backend-config="bucket=thrive-cluster-test-terraform-state" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=thrive-cluster-test-terraform-locks"

      - name: Terraform Validate
        id: validate
        run: terraform validate

      - name: Terraform Plan
        id: plan
        run: |
          terraform plan \
            -var="github_repo=${{ github.repository }}" \
            -var="aws_account_id=${{ secrets.AWS_ACCOUNT_ID }}" \
            -lock-timeout=5m \
            -out=tfplan

      - name: Terraform Apply
        id: apply
        run: terraform apply -auto-approve tfplan

  build-and-push:
    name: üî® Build and Push Image
    needs: deploy-infrastructure
    runs-on: ubuntu-latest
    environment: AWS_OIDC # GitHub Environment with AWS_ACCOUNT_ID secret
    permissions:
      id-token: write # Required for OIDC authentication
      contents: read
    outputs:
      ecr_repo_uri: ${{ steps.get-ecr.outputs.ECR_REPO }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/thrive-cluster-test-github-actions-role
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActionsBuild

      - name: Get ECR repository URI
        id: get-ecr
        run: |
          ECR_REPO=$(aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} --query 'repositories[0].repositoryUri' --output text)
          echo "ECR_REPO=$ECR_REPO" >> $GITHUB_OUTPUT

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image to ECR
        id: build-image
        working-directory: ./app
        run: |
          docker build -t ${{ steps.get-ecr.outputs.ECR_REPO }}:${{ env.IMAGE_TAG }} .
          docker tag ${{ steps.get-ecr.outputs.ECR_REPO }}:${{ env.IMAGE_TAG }} ${{ steps.get-ecr.outputs.ECR_REPO }}:latest
          docker push ${{ steps.get-ecr.outputs.ECR_REPO }} --all-tags
          echo "Image pushed successfully!"

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.get-ecr.outputs.ECR_REPO }}:${{ env.IMAGE_TAG }}
          format: 'table'
          output: 'trivy-results.txt'

      - name: Display Trivy scan results
        if: always()
        run: |
          echo "## Trivy Security Scan Results" >> $GITHUB_STEP_SUMMARY
          if [ -f "trivy-results.txt" ]; then
            cat trivy-results.txt >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è No scan results found" >> $GITHUB_STEP_SUMMARY
          fi

  deploy-application:
    name: üöÄ Deploy Application
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: AWS_OIDC # GitHub Environment with AWS_ACCOUNT_ID secret
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/thrive-cluster-test-github-actions-role
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActionsDeploy

      - name: Update kubeconfig for EKS
        run: aws eks update-kubeconfig --name ${{ env.CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

      - name: Deploy to EKS with Kustomize
        run: |
          echo "üîß Updating Kustomize configuration..."
          # Replace placeholders for IAM Role ARNs and other AWS-specific values
          find k8s/base -name "*.yaml" -exec sed -i "s|ACCOUNT_ID|${{ secrets.AWS_ACCOUNT_ID }}|g" {} \;
          find k8s/base -name "*.yaml" -exec sed -i "s|REGION|${{ env.AWS_REGION }}|g" {} \;

          # Use kustomize command to set the new image, which is safer than sed
          cd k8s/base
          kustomize edit set image ${{ needs.build-and-push.outputs.ecr_repo_uri }}:${{ env.IMAGE_TAG }}
          cd ../..

          echo "üìã Generated kustomization.yaml:"
          cat k8s/base/kustomization.yaml

          echo "üöÄ Deploying application with Kustomize..."
          kubectl apply -k k8s/base
          echo "‚úÖ All Kubernetes resources applied successfully."

      - name: Wait for deployments to be ready
        run: |
          echo "‚è≥ Waiting for deployments to be ready..."
          kubectl rollout status deployment/hello-world -n hello-world --timeout=5m
          kubectl rollout status deployment/hello-world-pod-identity -n hello-world --timeout=5m

      - name: Verify deployments
        run: |
          echo "üîç Final verification of deployed resources..."
          kubectl get all -n hello-world

  notify:
    name: üîî Notify Status
    needs: deploy-application
    runs-on: ubuntu-latest
    if: always() # Ensures this job runs even if the deployment fails
    steps:
      - name: Notify deployment status
        run: |
          if [ "${{ needs.deploy-application.result }}" == "success" ]; then
            echo "‚úÖ Deployment Succeeded!"
          else
            echo "‚ùå Deployment Failed!"
            # Add steps here to send a notification to Slack, Teams, etc.
          fi